## ДЗ №2

Запускаем контейнер и подключаемся к базе с двух терминалов

`
docker container start <container_id>
`

`
docker exec -it test_db psql -U postgres
`

В первой сессии создаем таблицу и добавляем в нее строку

```sql
create table if not exists test_table (
  id serial primary key,
  name text
);

insert into test_table (name) values ('Alex');
```

Вычитываем данные из таблицы во второй сессии, видим новую запись. Проверяем уровень изоляции - 'read commited'

```sql
select * from test_table;

show transaction_isolation;
```

В обеих сессиях открываем транзакцию (не меняя дефолтного уровня)

```sql
begin;
```

В первой сессии добавляем еще одну запись

```sql
insert into test_table (name) values ('Bob');
```

Проверяем во второй сессии и не находим запись. Это вызвано тем, что используется дефолтный уровень изоляции read commited - изменения, добавленные другой транзакцией, будут видны только после коммита этой транзакции.
Делаем коммит в первой сессии.

```sql
commit;
```

Теперь запись видна во второй сессии

Снова запускаем две транзакции, но на этот раз устанавливаем во второй сессии уровень изоляции REPEATABLE READ

```sql
begin;
set transaction isolation level repeatable read;
```

Добавляем новую запись в первой сессии

```sql
insert into test_table(name) values('Charlie');
```

Проверяем таблицу во второй сессии - записи нет. Делаем коммит в первой сессии, но после этого запись тоже не появляется.
Это обусловлено тем, что уровень изоляции repeatable read гарантирует, что в ходе транзакции этого уровня (в нашем случае сессия 2) изменения сделанные вне транзакции видны не будет - по сути, делается слепок данных на момент set transaction level (именно set а не begin), который используется до конца транзакции.
Сделав коммит во второй сессии, мы уже можем видеть изменения, сделанные в первой.
